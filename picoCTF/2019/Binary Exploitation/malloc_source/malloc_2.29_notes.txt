malloc 2.29 notes

-----------------------------------------------------tcache-----------------------------------------------------

This version of malloc uses a tcache, which has special rules. tcache entries and removals have no extra checks, apart from what is in the malloc and free functions. They always return exact fit bins.

Tcache bins are like fastbins; Each bin contains only chunks of a specific size. The only difference is that these bins can be of any size. I'm pretty sure there's also a max size for a tcache chunk, but it shouldn't be something I have to worry about right now.

Tcache chunks are stored in a singly linked list, so instead of fwd and bck pointers, they only have a next pointer.

tcache_put(ptr, size):
{
Mark chunk as "in the tcache" to make double free detection work
ptr -> next = top chunk of tcache bin with size size
top chunk = ptr
}

tcache_get(size):
{
ptr = top chunk of tcache bin with size size
top chunk = ptr -> next
return ptr
}

These functions are super insecure; there are NO CHECKS at all! That means that if you can overwrite a tcache pointer, you've basically got a free write-what-where exploit!

-----------------------------------------------------malloc(size)-----------------------------------------------------
First in __libc_malloc():
If entry of wanted size is in tcache, tcache_get(size) and return
Note: THERE ARE NO CHECKS BEFORE OR AFTER THIS CALL!!! (Huge exploit opportunity)
Else, go to _int_malloc()

_int_malloc():
Fastbin removal:
{
Once a matching size has been found:
Check: Chunksize of chunk in fastbin as based on chunk metadata does not match expected size of that fastbin -> "malloc(): memory corruption (fast)"

If tcache is being used: Copy all the chunks from the checked fastbin to the tcache if it's not full (max = 127). Remove the chunks from the bin via a recursive call to this fastbin removal function. Uses tcache_put(chunk).

Return the chunk found
}

Smallbin removal:
{
Once a matching size has been found (the top one):
Let matching chunk = victim
Check: If victim -> bk -> fd != victim, error with "malloc(): smallbin double linked list corrupted"
Set inuse bit of next, and remove victim from the doubly linked list
smallbin -> bk = victim -> bk
victim -> bk -> fd = smallbin

If tcache is being used: Copy all the chunks from the checked smallbin to the tcache if it's not full (max = 7). Remove the chunks from the bin via a recursive call to this smallbin removal function. Uses tcache_put(chunk).

Return the chunk found
}

Unsorted / tcache removal:
{
For each chunk in unsorted chunks (referred to from now on as victim):
{
Check: Valid size (>16/32, <system memory amount) -> "malloc(): invalid size (unsorted)"
Check: Valid next size -> "malloc(): invalid next size (unsorted)"
Check: Prev size field of (technically next) chunk != Size field of chunk -> "malloc(): mismatching next->prev_size (unsorted)"
Check: victim -> bk -> fd != victim, then error "malloc(): unsorted double linked list corrupted"
Check: If previnuse(next) -> "malloc(): invalid next->prev_inuse (unsorted)"

Remove from unsorted list
Take the chunk now instead of binning if it's an exact fit
{
If tcache off, just return it
Else, put the exact fit into the tcache, but continue iterating through other chunks
}
Else, put the chunk in the right bin
{
victim -> bk = right_bin -> bk
victim -> fd = right_bin -> fd
right_bin -> fd -> bk = victim
right_bin -> bk -> fd = victim
}

If tcache on and cache filled, tcache_get(size) and return
}

If tache on and cache is not empty (exact fit found), tcache_get(size) and return

If no chunks were found, use top
Check: top size > system amount -> "malloc(): corrupted top size"
Just remove a bit of size from top, and return that chunk
}

-----------------------------------------------------free(ptr)-----------------------------------------------------
First check: If chunksize(ptr) as found in the chunk data is negative, or isn't aligned (8 for 32-bit, 16 for 64-bit), then error with "free(): invalid pointer"
Second check: If chunksize(ptr) is less then the minimum allowed alloc size (16 for 32-bit, 32 for 64-bit), or the chunksize isn't a multiple of 8 or 16 (32/64 bit), then error with "free(): invalid size"

If tcache is being used:
{
Check: Is ptr being double freed? (Checks if ptr exists in tcache already) -> Raise error "free(): double free detected in tcache 2"
tcache_put(ptr, size found in chunk data), and return
Note that this is triggered no matter what size the chunk is, as long as there aren't 7 chunks already in the bin.
}

Otherwise, do something. Not really important if you never have more than 7 chunks.