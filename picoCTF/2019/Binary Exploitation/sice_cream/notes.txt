Partial solution (leaks pointers):

malloc(72), then malloc(72). free(0), free(1), then free(0) to create a double-free exploit. malloc(72) to modify the pointer for the second free. Modify this pointer to point to near the end of the name_buf (leave 24 bytes of space for chunk metadata control). Then, change your name to create a valid chunk at that location (all you need to do to past the check is to set the chunksize field to 72).

ice_cream[] state:
0 = 1st chunk (size 72) "FREE"
1 = 2nd chunk (size 72) FREE
2 = 1st chunk (size 72) "FREE"

Next, malloc(72), then malloc(72) again to get rid of the two frees, then malloc(72) AGAIN to get the fake chunk in the name buffer. Write 'A'*8, then a pointer to the start of the name_buf in this fake chunk, overwriting the first pointer in the ice cream array.

ice_cream[] state:
0 = Start of name_buf (size ?) N/A
1 = 2nd chunk (size 72) USED
2 = 1st chunk (size 72) USED
3 = 2nd chunk (size 72) USED
4 = 1st chunk (size 72) USED
5 = Fake chunk near end of name_buf (size 72) USED

free(4), then free(5) to get a pointer to the top chunk of the heap placed in the fake chunk you created in name_buf. Change your name to a string long enough to see the pointer to the heap, and when the program prints your name, it'll leak the heap pointer! :)

ice_cream[] state:
0 = Start of name_buf (size ?) N/A
1 = 2nd chunk (size 72) USED
2 = 1st chunk (size 72) FREE
3 = 2nd chunk (size 72) USED
4 = 1st chunk (size 72) FREE
5 = Fake chunk near end of name_buf (size 72) N/A (Invalid due to overwrite to view pointer)

From here, your goal is to make a fake chunk that is bigger than the fastbin size, to get the program to leak a libc pointer. Then, you can use the unlink() exploit to overwrite __malloc_hook() (no doubly linked list check in this version of libc yet), and get a shell. You know the location of the heap now, so you can go from there.

----------------------------------------------------------------------------------------------------------------------

Writes into name buffer, which is a global, so you can access it from anywhere... hmm.....
Name is maximum 256 characters long.

Array of ice cream = Pointers to locations in malloc, in globals

Max # of ice cream flavors? = 20, but the function lets you have 21 flavors actually - Possible off-by-one?

Does the same thing as 3. at the start of program.

1. Buy sice icream
Max amount of ice cream = 88 (89 will error)
Mallocs amount that you give
Reads whatever you type in as the ice cream flavor into the malloced area (safe call, no overflow possible)
Only reads your amount of ice cream - 1 character, adding newline at the end

2. Eat sice icream
Max sice cream to eat = 20 (21 will error)
"Free"s the sice cream that you pick (zero-indexed)
But the algorithm doesn't work...??????
First of all, it doesn't check for possibility of double-free, so that's concerning.
Also, it doesn't do the "cdqe" thing like the other ones, so the address it clears isn't right. Instead of going 0, 16, 32... bytes, it does 0, 8, 16..., which won't even free the right thing...????

Actually... it seems to work? I don't know. Just go with it I guess.

Anyways, this doesn't really seem to help with the actual exploit. Just note that in order to free stuff CORRECTLY, you're gonna have to use odd numbers only. (0 -> 1, 1 -> 3, 2 -> 5, etc.). It also means that you really only have 10 ice cream flavors to work with (21 will error).

3. Reintroduce yourself
Just replaces the stuff inside the char* name array with something. Max length of 256 characters. This doesn't actually clear the whole name array; it just overwrites some starting part of it with stuff (newline characters).

Read doesn't stop at any characters; you can input as many nulls and/or newlines as you want.

Interesting note: The pointers are never removed in the array; they're always there. These things all really suggest a use-after-free / double-free exploit.

GDB commands

name_buf = x/100x 0x602040
ice_cream_arr = x/50x 0x602140
ice_cream_heap = x/100x 0x603000

Alright, so this seems like a double-free exploit. Make 2 ice cream 'orders', free 0, then 1, then 0 (to bypass the double free detection).

Now the linked list is BIN -> 0 -> 1 -> 0. You can then use the fact that you control the pointer to 0 after the first malloc()... so now you have a semi-controlled write-what-where exploit!

To overwrite the GOT entry: 0x601fd8 should be the new address.

libc source
Checks at line 2320 of libc 2.2.3.
Chunk free() at line 3150.