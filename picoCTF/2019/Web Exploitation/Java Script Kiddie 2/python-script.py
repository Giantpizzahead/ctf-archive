import base64

bytes = [189,175,157,28,66,234,251,229,0,199,119,0,79,235,247,102,128,200,11,207,13,140,27,30,1,196,27,13,151,252,252,125,69,73,68,158,0,63,130,22,84,157,0,0,201,231,70,158,137,141,78,234,126,191,26,110,27,91,0,237,240,0,157,191,0,29,1,0,26,59,1,29,244,0,0,224,227,0,0,164,164,255,0,252,72,243,68,0,45,0,156,59,121,72,0,188,48,78,133,60,106,252,178,10,231,0,81,122,0,192,68,223,125,80,62,174,223,216,25,114,22,120,97,222,0,77,95,73,13,0,195,71,126,96,33,65,51,204,84,254,73,173,142,0,248,0,196,114,36,10,193,132,83,102,119,160,0,221,190,82,143,16,18,2,143,0,239,9,223,158,169,194,155,187,234,108,243,148,243,191,251,73,149,242,0,157,81,235,102,231,92,163,116,73,223,192,243,144,27,121,2,131,168,5,36,62,157,153,13,78,152,168,11,102,61,70,223,107,55,180,101,208,80,63,27,183,88,95,183,17,242,39,58,113,2,241,121,166,72,152,206,27,27,109,96,194,39,243,73,135,254,22,55,99,192,127,165,203,19,131,145,202,246,206,35,67,47,98,17,251,180,143,176,11,151,91,131,41,177,10,243,232,70,66,100,4,113,146,213,127,252,89,45,243,251,96,85,249,152,249,235,204,193,82,56,255,206,143,205,104,113,166,237,201,153,214,22,247,204,22,141,21,12,95,243,219,126,113,211,185,49,70,54,80,212,61,232,167,125,92,57,111,132,182,88,154,49,199,209,54,140,160,157,239,36,147,158,64,72,50,213,239,164,216,91,127,160,122,185,61,17,59,248,106,10,241,156,236,252,10,223,122,231,187,24,221,32,223,202,253,46,165,252,111,1,114,119,181,119,253,113,82,91,76,212,183,213,77,61,239,51,238,139,241,209,145,36,255,127,221,147,196,213,123,148,90,37,107,101,150,239,214,64,241,77,114,125,48,211,33,87,186,248,249,165,12,71,250,177,130,68,186,242,98,151,181,185,85,0,156,113,203,131,73,157,126,39,254,95,115,169,231,61,215,163,186,144,210,34,217,150,185,231,190,255,129,250,239,68,247,230,20,221,107,75,233,120,74,62,15,228,82,77,22,168,11,174,11,66,98,175,102,239,111,249,173,207,95,173,197,214,187,223,45,108,84,229,156,249,127,52,180,147,123,92,12,115,164,88,104,39,71,50,11,252,215,12,74,75,164,48,172,121,9,112,190,98,207,35,250,189,125,119,67,191,86,109,85,99,1,73,234,208,231,239,157,156,17,231,40,71,151,3,15,147,139,88,63,183,87,247,13,185,171,239,107,205,247,159,36,249,70,149,111,110,241,157,247,211,165,192,42,71,230,113,212,95,191,50,216,183,26,252,65,227,233,237,43,220,210,232,208,163,7,11,138,215,33,210,144,153,95,91,254,183,226,164,240,217,254,249,187,254,220,193,172,223,92,153,39,27,208,7,126,231,255,79,213,63,9,47,30,211,2,229,84,40,167,155,243,46,141,249,222,219,179,136,98,245,84,20,198,18,243,36,199,0,207,143,0,249,40,80,218]
# Length of bytes: 704
# Number of 16-byte chunks: 44

# Apparently the odd indexed key values don't matter at all
# Maybe a bug in how picoCTF designed the algorithm, but whatever

"""
Output:
Valid shifts at index 0: [3]
Valid shifts at index 1: [7]
Valid shifts at index 2: [3]
Valid shifts at index 3: [8]
Valid shifts at index 4: [1]
Valid shifts at index 5: [9]
Valid shifts at index 6: [3]
Valid shifts at index 7: [6]
Valid shifts at index 8: [0]
Valid shifts at index 9: [4, 5, 6]
Valid shifts at index 10: [2, 3, 4]
Valid shifts at index 11: [1]
Valid shifts at index 12: [8]
Valid shifts at index 13: [5]
Valid shifts at index 14: [6]
Valid shifts at index 15: [9]

Brute force the 9 possibilities
Actually just gen them and copy-paste until the right one's found

Keys to test:
30703080109030600040201080506090
30703080109030600040301080506090
30703080109030600040401080506090
30703080109030600050201080506090
30703080109030600050301080506090
30703080109030600050401080506090
30703080109030600060201080506090
30703080109030600060301080506090
30703080109030600060401080506090

Correct key: 30703080109030600050301080506090
picoCTF{3aa9bd64cb6883210ee0224baec2cbb4}
"""

def main():
    # Going about shifter of 43 is meaningless (loops around)
    # So, only check shifts of 00 to 43
    # Actually even that's meaningless
    # Only check shifts from 00 to 90

    print("Finding keys that match the PNG signature format for each byte")
    targets = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0d, ord('I'), ord('H'), ord('D'), ord('R')]
    working = [[] for _ in range(16)]
    for s in range(10):
        print("Testing shift " + str(s))
        result = assemble_shift(s * 10)
        for c in range(16):
            plaintext = decode_bytes(result)
            if ord(plaintext[c]) == targets[c]:
                # Working shift for this byte location
                working[c].append(s)

    # Print out valid keys
    for i in range(16):
        print("Valid shifts at index " + str(i) + ":", working[i])

    print("\n\nKeys to test:")
    gen_keys(working, 0, "")


def gen_keys(working, index, curr_out):
    if index == 16:
        print(curr_out)
        return
    for c in working[index]:
        gen_keys(working, index+1, curr_out+str(c)+"0")


'''
Simulates the JavaScript function.
'''
def assemble_png(user_in):
    LEN = 16
    key = "00000000000000000000000000000000"
    if len(user_in) == len(key):
        key = user_in

    result = [-1 for i in range(len(bytes))]
    for i in range(LEN):
        shifter = int(key[i*2:i*2+1])
        for j in range(len(bytes) // LEN):
            result[(j * LEN) + i] = bytes[(((j + shifter) * LEN) % len(bytes)) + i]

    while result[len(result) - 1] == 0:
        result = result[:-1]

    return result


def assemble_shift(shift):
    print("{0:02d}".format(shift)*16)
    return assemble_png("{0:02d}".format(shift)*16)


def to_base64(result):
    return base64.encodebytes(bytearray(result))


def decode_bytes(result):
    return ''.join(map(chr, result))


if __name__ == "__main__":
    main()
