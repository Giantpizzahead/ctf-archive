"""
Decrypts a cookie for the "Magic Padding Oracle" picoCTF problem.
Uses a modified version of the padding oracle exploit to decrypt a cookie.

Warning: This takes a verrrrrrrrrrry long time to run, so I wouldn't suggest doing that.
"""

import socket

SERVER = "2018shell.picoctf.com"
PORT = 27533
BUFFER_SIZE = 4096
HEX = "0123456789abcdef"
DEBUG = True
DEBUG_LOW = False
DEBUG_LOWEST = False


def main():
    print(decrypt("ddd7ecf14579dbbfac853ebcc7bf8d11fd8703dce82b480d21dfb56717e3a1ec"))
    s.close()


def decrypt(cookie):
    """
    Decrypts the given cookie. Returns the decrypted cookie.
    """
    blocks = make_blocks(cookie)
    if DEBUG_LOW: print(blocks)

    # Decrypt each block separately
    decrypted_blocks = []
    for i in range(len(blocks)-1, 0, -1):
        decrypted_blocks.append(decrypt_block(blocks[i], blocks[i-1]))

    # Reverse decrypted blocks to get the decrypted output
    decrypted_blocks = decrypted_blocks[::-1]
    output = ""
    for block in decrypted_blocks:
        output += block
    return output


def decrypt_block(block, previous_cipher_block):
    """
    Decrypts the given block. Returns the decrypted block.
    """
    if DEBUG: print("Decrypting block " + block)

    padding_bytes = []
    plaintext_bytes = []
    previous_block = ""
    decrypted_block = ""

    # Main decryption loop
    for i in range(16):
        if DEBUG:
            print("Checking index " + str(i))
            print("Previous block cipher: " + previous_block)
        # Find a byte that has valid padding
        ciphered_byte = find_valid_byte(block, previous_block)
        # Figure out the value of the plaintext byte
        if i == 0:
            actual_byte = decipher_byte(block, previous_block, ciphered_byte)
        else:
            actual_byte = i + 1

        # Figure out the plaintext value at the current byte
        original_byte = actual_byte ^ get_num_from_index(previous_cipher_block, 15-i) ^ ciphered_byte
        print(original_byte)
        plaintext_bytes.append(original_byte)
        if DEBUG: print("Original character at index " + str(i) + ": " + chr(original_byte))

        # Update any previous bytes
        for j in range(len(padding_bytes)):
            padding_bytes[j] = (i + 2) ^ plaintext_bytes[j] ^ get_num_from_index(previous_cipher_block, 15-j)

        # Figure out the new padding byte needed to check for next padding amount
        padding_byte = (i + 2) ^ original_byte ^ get_num_from_index(previous_cipher_block, 15-i)
        # Add this needed byte to the previous_block string
        padding_bytes.append(padding_byte)

        # Update the previous_block string
        previous_block = ""
        for byte in padding_bytes[::-1]:
            previous_block += hex_string(byte)

    decrypted_block = ""
    for byte in plaintext_bytes[::-1]:
        decrypted_block += chr(byte)
    if DEBUG: print("Decrypted block: " + decrypted_block)
    return decrypted_block


def decipher_byte(cipher_block, previous_block, ciphered_byte):
    """Deciphers the given byte. In other words, finds out the plaintext value of that byte."""
    # Test previous bytes
    previous_block = hex_string(ciphered_byte) + previous_block
    actual_byte = len(previous_block) // 2
    while len(previous_block) < 32:
        # Add 1 to the next byte in the cookie
        cookie = "01" + previous_block
        cookie = pad_front(cookie) + cipher_block

        # Send the cookie
        result = try_cookie(cookie)
        # Check result for valid or invalid padding
        if is_valid_padding(result):
            # Padding is valid, no need to check further
            if DEBUG_LOW: print("Actual value of ciphered_byte " + str(ciphered_byte) + " is " + str(actual_byte))
            return actual_byte
        else:
            # Padding is not valid, meaning this byte is part of the padding; keep checking
            actual_byte += 1
            previous_block = "00" + previous_block

    # Got to the end, meaning the padding covers the entire block
    if DEBUG_LOW: print("Actual value of ciphered_byte " + str(ciphered_byte) + " is " + str(actual_byte))
    return actual_byte


def find_valid_byte(cipher_block, previous_block):
    """Finds a valid byte that does not cause a padding error. Returns that byte."""
    # Try every possible byte
    if DEBUG_LOW and not DEBUG_LOWEST: print("Trying cookies ", end='')
    for byte in range(0, 256):
        # Make the cookie
        cookie = hex_string(byte) + previous_block
        cookie = pad_front(cookie) + cipher_block
        if DEBUG_LOW and not DEBUG_LOWEST: print(hex_string(byte) + " ", end='')

        # Send the cookie
        result = try_cookie(cookie)
        # Check result for valid or invalid padding
        if is_valid_padding(result):
            # Valid byte found
            if DEBUG_LOWEST: print(result)
            elif DEBUG_LOW: print()
            if DEBUG: print("Valid byte found: " + str(byte))
            return byte

    # All bytes tried, with no valid padding...?
    raise Exception("No valid byte found for\ncipher_block " + cipher_block + "\nprevious_block " + previous_block)


def get_num_from_index(block, i):
    if DEBUG_LOWEST: print("Getting byte at index " + str(i) + " from block " + block)
    if DEBUG_LOWEST: print("Byte: " + block[i * 2 : i * 2 + 2] + " " + str(int(block[i * 2 : i * 2 + 2], 16)))
    return int(block[i * 2 : i * 2 + 2], 16)


def hex_string(num):
    return HEX[num // 16] + HEX[num % 16]


def is_valid_padding(result):
    return "JSON" in result or "KeyError" in result or "expired" in result


def make_blocks(cookie):
    """
    Splits the given cookie into 16-byte blocks (32 hexadecimal digits).
    """
    blocks = []
    for i in range(0, len(cookie), 32):
        blocks.append(cookie[i:i+32])
    return blocks


def pad_front(text):
    """
    Pads the front of text with enough zeroes to make it 32 characters long.
    """
    return '0'*(32 - len(text)) + text


def try_cookie(cookie):
    global s
    if DEBUG_LOWEST: print("Trying cookie " + cookie)
    while True:
        try:
            s = socket.socket()
            s.connect((SERVER, PORT))
            s.recv(BUFFER_SIZE)
            s.recv(BUFFER_SIZE)
            s.sendall(cookie.encode("utf-8") + b'\n')

            # Receive all error data
            output = ""
            while True:
                line = s.recv(BUFFER_SIZE).decode("utf-8")
                output += line
                if "Error" in line or "invalid" in line or "expired" in line or "picoCTF{" in line:
                    break
            s.close()
            break
        except Exception as e:
            print(e)
    return output


if __name__ == "__main__":
    main()