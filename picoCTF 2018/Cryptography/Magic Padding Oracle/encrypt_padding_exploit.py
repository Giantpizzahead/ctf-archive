"""
Generates an encrypted cookie for the "Magic Padding Oracle" picoCTF problem.
Uses a modified version of the padding oracle exploit to encrypt
a cookie that is admin and is not expired.

Warning: This takes a verrrrrrrrrrry long time to run, so I wouldn't suggest doing that.
"""

import socket
import math
# import random

SERVER = "2018shell.picoctf.com"
PORT = 27533
BUFFER_SIZE = 4096
KNOWN_BYTES = {
    "a4326ed9573d1fb5f5c47f859f40f0f0": [208, 122, 44, 96, 184, 20, 215, 224, 132, 199, 152, 196, 103, 215, 127, 97],
    "1014b403a6b1f7adcaa460c8010d05d0": [96, 50, 37, 240, 15, 134, 251, 119, 110, 81, 224, 105, 202, 143, 252, 32],
    "00c1b1ea55d2765746deac2ad64f433e": [20, 175, 116, 129, 194, 20, 198, 79, 64, 115, 92, 211, 125, 35, 195, 48],
    "02e00d52ba2f092035a461e5bf578f27": [197, 152, 90, 75, 128, 187, 146, 1, 45, 195, 239, 17, 158, 205, 243, 48]
}
HEX = "0123456789abcdef"
DEBUG = False
DEBUG_LOW = False
DEBUG_LOWEST = False


def main():
    cookie_to_encrypt = """{"username": "hi", "expires": "2020-09-09", "is_admin": "true"}\x01"""
    if DEBUG:
        print("Cookie length:", len(cookie_to_encrypt))
    assert len(cookie_to_encrypt) % 16 == 0,\
        "Cookie length must be a multiple of 16 (currently {})".format(len(cookie_to_encrypt))
    cookie = encrypt(cookie_to_encrypt)
    print("Cookie: " + cookie)
    print("\nTrying cookie...\n______________________________________\n")
    print(try_cookie(cookie))
    s.close()


def encrypt(plaintext):
    """
    Generates a cookie with the given plaintext. Returns the generated cookie.
    """
    reversed_text = plaintext[::-1]
    blocks = [generate_random_block()]
    num_blocks_needed = math.ceil(len(plaintext) // 16)

    # Encrypt each new block separately
    for i in range(num_blocks_needed):
        blocks.append(encrypt_new_block(blocks[i], reversed_text[i*16:(i+1)*16]))

    # Reverse encrypted blocks to get the whole cookie
    blocks = blocks[::-1]
    output = ""
    print("Generated cookie blocks:")
    for block in blocks:
        output += block
        print(block)
    return output


def encrypt_new_block(block, plaintext):
    """
    Generates a new cipher block in such a way that the passed in block will now
    decrypt to the given plaintext.
    """
    if DEBUG:
        print("\nGenerating cipher block for " + block)
        print("Plaintext: " + plaintext)

    padding_bytes = []
    ciphered_bytes = []
    actual_bytes = []
    new_block_bytes = []
    previous_block = ""

    if block not in KNOWN_BYTES:
        KNOWN_BYTES[block] = []

    # Main encryption loop
    for i in range(16):
        if DEBUG:
            print("\nChecking index", i)
            print("Previous block cipher:", previous_block)
            print("New block bytes so far:", new_block_bytes)
            print("Known bytes:", KNOWN_BYTES[block])

        # Find a byte that has valid padding
        ciphered_byte = find_valid_byte(block, previous_block)
        ciphered_bytes.append(ciphered_byte)

        # Figure out the value of the plaintext byte
        if i == 0:
            actual_byte = decipher_byte(block, previous_block, ciphered_byte)
        else:
            actual_byte = i + 1
        actual_bytes.append(actual_byte)

        # Add new padding byte / update all old padding bytes in order to check the next byte
        padding_bytes.append(0)
        for j in range(len(padding_bytes)):
            padding_bytes[j] = (i + 2) ^ actual_bytes[j] ^ ciphered_bytes[j]

        # Figure out the correct ciphered byte to use to produce the correct plaintext character
        new_block_byte = ord(plaintext[i]) ^ actual_bytes[i] ^ ciphered_bytes[i]
        if DEBUG_LOW:
            print("New block byte at index " + str(i) + " is " + hex_string(new_block_byte))
            print("This block byte represents the character " + plaintext[i])

        new_block_bytes.append(new_block_byte)

        # Update the previous_block string
        previous_block = ""
        for byte in padding_bytes[::-1]:
            previous_block += hex_string(byte)

    new_cipher_block = ""
    for byte in new_block_bytes[::-1]:
        new_cipher_block += hex_string(byte)
    if DEBUG:
        print("Known bytes entry to add:")
        print("\"{}\": {}".format(block, KNOWN_BYTES[block]))
        print("Generated block: " + new_cipher_block)
    return new_cipher_block


def decipher_byte(cipher_block, previous_block, ciphered_byte):
    """Deciphers the given byte. In other words, finds out the plaintext value of that byte."""
    # Test previous bytes
    previous_block = hex_string(ciphered_byte) + previous_block
    actual_byte = len(previous_block) // 2
    while len(previous_block) < 32:
        # Add 1 to the next byte in the cookie
        cookie = "01" + previous_block
        cookie = pad_front(cookie) + cipher_block

        # Send the cookie
        result = try_cookie(cookie)
        # Check result for valid or invalid padding
        if is_valid_padding(result):
            # Padding is valid, no need to check further
            if DEBUG_LOW:
                print("Actual value of ciphered_byte " + str(ciphered_byte) + " is " + str(actual_byte))
            return actual_byte
        else:
            # Padding is not valid, meaning this byte is part of the padding; keep checking
            actual_byte += 1
            previous_block = "00" + previous_block

    # Got to the end, meaning the padding covers the entire block
    if DEBUG_LOW:
        print("Actual value of ciphered_byte " + str(ciphered_byte) + " is " + str(actual_byte))
    return actual_byte


def find_valid_byte(cipher_block, previous_block):
    """Finds a valid byte that does not cause a padding error. Returns that byte."""
    # Don't waste time looking for already found bytes
    if cipher_block in KNOWN_BYTES and len(KNOWN_BYTES[cipher_block]) > len(previous_block) // 2:
        if DEBUG:
            print("Already found this byte: " + str(KNOWN_BYTES[cipher_block][len(previous_block) // 2]))
        return KNOWN_BYTES[cipher_block][len(previous_block) // 2]

    # Try every possible byte
    if DEBUG_LOW and not DEBUG_LOWEST:
        print("Trying cookies ", end='')

    for byte in range(256):
        # Make the cookie
        cookie = hex_string(byte) + previous_block
        cookie = pad_front(cookie) + cipher_block
        if DEBUG_LOW and not DEBUG_LOWEST:
            print(hex_string(byte) + " ", end='')

        # Send the cookie
        result = try_cookie(cookie)
        # Check result for valid or invalid padding
        if is_valid_padding(result):
            # Valid byte found
            if DEBUG_LOWEST:
                print(result)
            elif DEBUG_LOW:
                print()
            if DEBUG:
                print("Valid byte found: " + str(byte))
            KNOWN_BYTES[cipher_block].append(byte)
            return byte
        if DEBUG_LOWEST:
            print(result)

    # All bytes tried, with no valid padding...?
    raise Exception("No valid byte found for\ncipher_block " + cipher_block + "\nprevious_block " + previous_block)


def generate_random_block():
    return "a4326ed9573d1fb5f5c47f859f40f0f0"


def get_num_from_index(block, i):
    if DEBUG_LOWEST:
        print("Getting byte at index " + str(i) + " from block " + block)
        print("Byte: " + block[i * 2:i * 2 + 2] + " " + str(int(block[i * 2:i * 2 + 2], 16)))
    return int(block[i * 2:i * 2 + 2], 16)


def hex_string(num):
    return HEX[num // 16] + HEX[num % 16]


def is_valid_padding(result):
    line_location = result.find("/pkcs7.py\", line ")
    if line_location > 46 or "expired" in result:
        return True
    else:
        return False
    # return "JSON" in result or "json" in result or "KeyError" in result or "expired" in result


def make_blocks(cookie):
    """
    Splits the given cookie into 16-byte blocks (32 hexadecimal digits).
    """
    blocks = []
    for i in range(0, len(cookie), 32):
        blocks.append(cookie[i:i+32])
    return blocks


def pad_front(text):
    """
    Pads the front of text with enough zeroes to make it 32 characters long.
    """
    return '0'*(32 - len(text)) + text


def try_cookie(cookie):
    global s
    if DEBUG_LOWEST:
        print("Trying cookie " + cookie)
    while True:
        try:
            s = socket.socket()
            s.connect((SERVER, PORT))
            s.recv(BUFFER_SIZE)
            s.recv(BUFFER_SIZE)
            s.sendall(cookie.encode("utf-8") + b'\n')

            # Receive all error data
            output = ""
            while True:
                line = s.recv(BUFFER_SIZE).decode("utf-8")
                output += line
                if "Error" in line or "invalid" in line or "expired" in line or "picoCTF{" in line:
                    break
            s.close()
            break
        except Exception as e:
            print(e)
    return output


if __name__ == "__main__":
    main()
