N: 374159235470172130988938196520880526947952521620932362050308663243595788308583992120881359365258949723819911758198013202644666489247987314025169670926273213367237020188587742716017314320191350666762541039238241984934473188656610615918474673963331992408750047451253205158436452814354564283003696666945950908549197175404580533132142111356931324330631843602412540295482841975783884766801266552337129105407869020730226041538750535628619717708838029286366761470986056335230171148734027536820544543251801093230809186222940806718221638845816521738601843083746103374974120575519418797642878012234163709518203946599836959811
e: 3

ciphertext (c): 2205316413931134031046440767620541984801091216351222789180535786851451917462804449135087209259828503848304180574549372616172217553002988241140344023060716738565104171296716554122734607654513009667720334889869007276287692856645210293194853 

Key is that the e value is very small, meaning that there are only 3 possiblities for the private key (pretty sure). Use this to solve the problem!

No, that's not true. But it still has something to do with the low e value... probably.

d * 3 = 1 (mod totient(n))

d only has two possible values:

(totient(n) + 1) / 3
or
(2 * totient(n) + 1) / 3

These can be approximated to:

(n + 1) / 3
or
(2 * n + 1) / 3

So try decrypting using these values?

Cube rooting seems to be getting somewhere. Maybe try that?

Since encrypting works by exponentiating the cipher text by the exponent e, if the cipher text isn't long enough, then it never gets modded, meaning that to get the original cipher text, you can just cube root it.

Yep, that worked! You just needed to make a very precise root calculator (I did it using binary search).