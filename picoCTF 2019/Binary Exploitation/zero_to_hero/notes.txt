Solution:

malloc(24), then malloc(288). free(1), then free(0). Then, malloc(24) and write 'A'*24 to overflow the 288 malloc size and set it to 256. Then, free(1) again to create a double free.

Next, malloc(248) to get the 256 chunk from tcache, and write the pointer to __malloc_hook(). Then, malloc(288) to get the same chunk, and make tcache go to next pointer.

Finally, malloc(288) again to get the chunk in __malloc_hook, and write the pointer to one of the one_gadget options. Call malloc() with any size to execute the hook, and get a shell! :)

This uses exactly 7 mallocs. Just within the acceptable amount. Yay!

----------------------------------------------------------------------------------------------------------------------

To start the program, you must input 'y' at the start. This starting input is saved on the stack, so it might be useful for some reason.
Program gives you the system() C function pointer at the start

count_num_powers(): Returns the number of superpowers in the array. If 7 or more superpowers exist, return -1.

get_superpower():
Checks how many powers you have. If you have 7 or more, exits with an error.

First, asks you for the length of your description using scanf and %u.
If entered length is longer than 1032 characters, exits with an error.

Then, it mallocs an entry with your requested size, and saves the pointer to that location in the superpowers[] array.

Calls read with nbytes = input_size and buf = pointer to malloc() area.

Adds a null byte (\x00) at the end. POSSIBLE EXPLOIT (off-by-one)

remove_superpower():
Asks you for which power you want to remove using scanf and %u.
If entered index > 6, exits with an error.

free()'s the requested index. Uses tcache for removal.

Summary: There are two possible exploits here (double free and off-by-one). ASLR is off, but RELRO, the canary, and NX stack are all on. You're given the function pointer to the system() call. There are two main obstacles: One is the glibc checks for heap integrity. The other is the limited number of superpowers you can make (7 max). If you can pass these two obstacles using the two exploits, then you win!

Actually no, the tcache isn't vulnerable to double free attacks. There's some other way to combine these things to make the program vulnerable. You can't avoid the tcache, because it works for all sizes (including the max 1032).

You're allowed to make 7 superpowers max, which also can't avoid the tcache. So, the problem is obviously: How to exploit the tcache with only an off-by-one attack?

Idea: Put a chunk into the tcache by freeing it. Then, change that chunk's size using the off-by-one issue. Then, free that chunk again; tcache won't detect the double free because it's a different size. This gives you full control of the pointer to the next chunk!

Implementation: Allocate power of length 24, then one of length 288. Free both of them. Then, allocate power of length 24 (will use previously freed 24), and write 24 characters to it. This will overflow the length 288 one, changing it to 256. Then, free 1 again. This will succeed because it's a different length, and tcache only checks for double frees with the same length!

To use this double free, allocate a power of length 288, and do whatever you want with it. Then, allocate a power of length 256 to use the one you already have, creating a double chunk. :)

Now, find a way to get from this to code execution. You can do it! :D