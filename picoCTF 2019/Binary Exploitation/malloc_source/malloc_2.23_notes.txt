malloc 2.23 notes

-----------------------------------------------------malloc(size)-----------------------------------------------------

Fastbin allocation (0-80 bytes on 32-bit, 0-160 bytes on 64-bit):
{
Iterates through the singly linked list for the corresponding fastbin size.
Once it finds a chunk with the correct size (which it should do on the 1st iteration), it only does one check:
Check: Does the chunksize field in the actual chunk match the size that it's supposed to be? If not, raise an error (malloc(): memory corruption (fast)).
Else, just return the chunk without doing anything to the inuse bit.
}

NOTE: The below code will not run the first time, because all the small chunks will be in the unsorted chunks list!
Smallbin allocation (88-512 bytes on 32-bit, 176-1024 bytes on 64-bit):
{
Smallbins are still for an exact size, just like fastbins. So, there's no consolidation or anything.
Checks once a bin is found:
Check: found_chunk -> bk -> fd != found_chunk: Raise error "malloc(): smallbin double linked list corrupted"
After passing this test:
smallbin_start_loc -> bk = found_chunk -> bk
victim -> bk -> fd = smallbin_start_loc
Basically removing the found chunk from the free smallbin list.
Finally, returns the new chunk.
}

Unsorted allocation:
{
For every chunk in unsorted_chunks:
Check: If chunk size is not valid (too small or large), error with "malloc(): memory corruption"
Remove chunk from unsorted list
If chunk size is exact match with request, then stop right here; set inuse bit of next, and return this chunk. Don't iterate through the rest of unsorted_chunks.
Else, place the chunk in the right bin according to it's size.
}

-----------------------------------------------------free(ptr)-----------------------------------------------------

First check: If chunksize(ptr) as found in the chunk data is negative, or isn't aligned (8 for 32-bit, 16 for 64-bit), then error with "free(): invalid pointer"
Second check: If chunksize(ptr) is less then the minimum allowed alloc size (16 for 32-bit, 32 for 64-bit), or the chunksize isn't a multiple of 8 or 16 (32/64 bit), then error with "free(): invalid size"

Fastbin freeing:
{
Check: If next chunk's size as based on chunk metadata is smaller than minimum alloc size, or it's size is greater than the amount of allocated memory for the heap, then error with "free(): invalid next size (fast)"
Check: If first entry of the correct fastbin is equal to the current chunk you're attempting to free, then error with "double free or corruption (fasttop)"
Check: If size of top entry of correct fastbin is not equal to size of the chunk you're attempting to add, then error with "invalid fastbin entry (free)"
Finally, if no checks fail:
ptr->fd = top entry of correct fastbin (or NULL if fastbin is empty)
}

Any other size freeing:
{
Check: If block is already the top block, error with "double free or corruption (top)"
Check: If next chunk beyond boundaries of arena, error with "double free or corruption (out)"
Check: If block not marked used by the next chunk (calculated by using the size metadata in this chunk), error with "double free or corruption (!prev)"
Check: If next block's size as given by chunk metadata is not within min size (16/32) and max system allocated size, error with "free(): invalid next size (normal)"

If all checks pass:
{
Consolidate backward if !prev_inuse(ptr):
Get previous size field of last chunk, and add it to this chunk's size
Get the previous chunk using the previous size field to calculate the location of it
Call unlink(this_chunk, prev_chunk)

Consolidate forward if next chunk is not top and the prev_inuse bit of the next chunk's next chunk (determined by adding size to next chunk):
Call unlink(this_chunk, next_chunk)
Combine the two sizes

If next chunk is not top:
{
Add this chunk to the unsorted chunk list
Check: If top chunk of unsorted chunks -> fd -> bk != top chunk, raise error "free(): corrupted unsorted chunks"
If pass, insert this chunk into doubly linked list; set
ptr -> fd = top chunk -> fd (should be location of bin... but doesn't have to be!)
ptr -> bk = top chunk
top chunk -> fd -> bk = ptr
top chunk -> fd = ptr
}
Else, conslidate into top by combining the two sizes, and setting top to ptr
}
}


-----------------------------------------------------unlink()-----------------------------------------------------
Checks if the double-linked list is corrupted first by doing P->fd->bk == P and P->bk->fd == P

No more checks unless large bin
P->fd->bk = P->bk;
P->bk->fd = P->fd;

So basically unlinks P (either prev_chunk or next_chunk depending on which was called).